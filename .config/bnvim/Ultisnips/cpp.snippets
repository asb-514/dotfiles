snippet snips "all snippets"

/*
snips
z-function
hashing
gentree
pbds
prefsum
runningmedian
segtre
beg
minimal
siv
pfactor
for
fore
ya
na
read
vect
all
readvec
sort
pb
graph
tree
rootedtree
0rootedtree
gcd
binpow
inv
fact
fft
sufarr
aho
cht
segtree
centroid
sparse
decart
fenwick
fenwick2d
modular
table
{
dsu
*/

endsnippet
snippet gentre "generate tree"
int n = rnd.next(5, 6);
int t = rnd.next(-3, 3);

vector<int> p(n);
for (int i = 1; i < n; i++)
	p[i] = rnd.wnext(i, t);

vector<int> perm = rnd.perm(n);

vector<pair<int, int>> edges;
	for (int i = 1; i < n; i++)
if (rnd.next(2))
	edges.push_back(make_pair(perm[i], perm[p[i]]));
else
	edges.push_back(make_pair(perm[p[i]], perm[i]));

shuffle(edges.begin(), edges.end());
println(n);
for (auto edge : edges)
	println(edge.first + 1, edge.second + 1);
endsnippet


snippet for "for"
for (ll ${1:i} = 0; $1 < ${2:n}; $1++) {
	$0
}
endsnippet
snippet fore "for expanded"
for (ll ${1:i} = ${2:n - 1}; $1 ${3:>} ${4:-1}; $1${5:--}) {
	$0
}
endsnippet 
snippet ya "YES"
cout << "YES\n";
$0
endsnippet 
snippet na "NO"
cout << "NO\n";
$0
endsnippet 
snippet read "read first variable"
${1:ll} ${2:n};
cin >> $2;$0
endsnippet

snippet vect "vector"
vector<${1:ll}> ${2:a};$0
endsnippet

snippet all "all"
${1:arr}.begin(), $1.end()$0
endsnippet

snippet rvec "read vector"
vector<${1:ll}> ${2:a}(${3:n});
for ($1 &val : $2) {
	cin >> val;
}
$0
endsnippet

snippet wvec "write vector"
for (ll i = 0; i < sz(${1:ans}); i++) {
	cout << $1[i] << " \n"[i == sz($1) - 1];
}$0
endsnippet

snippet sort "read vector"
sort(${1:a}.begin(), $1.end());$0
endsnippet

snippet pb "push_back"
push_back($1);$0
endsnippet

snippet graph "read graph"
const int N =312345; // chech if input is > N

vector<int> g[N];
int used[N];

int solve() {
	int n;
	int m;
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		used[i] = 0;
		g[i].clear();
	}
	for (int i = 0; i < m; i++) {
		int x, y;
		cin >> x >> y;
		x--;
		y--;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	$0
	return 1;
}
endsnippet

snippet tree "read tree"
const int N = 312345;

vector<int> g[N];
int used[N];

int solve() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		used[i] = 0;
		g[i].clear();
	}
	for (int i = 1; i < n; i++) {
		int x, y;
		cin >> x >> y;
		x--;
		y--;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	$0
	return 1;
}
endsnippet

snippet rootedtree "read rooted tree"
const int N = 312345; // check if input is > N

vector<int> g[N];
int used[N], pr[N];

int solve() {
	int n;
	cin >> n;
	int root = -1;
	for (int i = 0; i < n; i++) {
		used[i] = 0;
		g[i].clear();
	}
	for (int i = 0; i < n; i++) {
		int p;
		cin >> p;
		if (p == -1) {
			root = i;
			continue;
		}
		p--;
		g[p].push_back(i);
		pr[i] = p;
	}
	$0
	return 1;
}
endsnippet

snippet 0rootedtree "read rooted in first vertex tree"
const int N = 312345; // check if input is > N

vector<int> g[N];
int used[N], pr[N];

int solve() {
	int n;
	if (!(cin >> n)) {
		return 1;
	}
	for (int i = 0; i < n; i++) {
		used[i] = 0;
		g[i].clear();
	}
	for (int i = 1; i < n; i++) {
		int p;
		cin >> p;
		p--;
		g[p].push_back(i);
		pr[i] = p;
	}
	$0
	return 1;
}
endsnippet

snippet table "table graph"
int dx[] = {0, 1, 0, -1};
int dy[] = {1, 0, -1, 0};
int n, m; // DON'T MAKE THEM IN MAIN

bool check(int x, int y) {
	return x >= 0 && x < n && y >= 0 && y < m;
}
endsnippet
