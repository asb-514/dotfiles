{
    "template": {
        "prefix": "template",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "typedef long long ll;",
            "typedef long double ld;",
            "typedef pair<ll, ll> pll;",
            "typedef vector<ll> vl;",
            "typedef vector<vl> vvl;",
            "typedef vector<pll> vll;",
            "typedef string str;",
            "",
            "#define sz(a) ((int)((a).size()))",
            "#define R(i, j, k) for (ll i = (j); i <= (k); ++i)",
            "#define N(i, n) for (ll i = (0); i < (n); ++i)",
            "#define L(i, j, k) for (ll i = (j); i >= (k); --i)",
            "#define all(x) (x).begin(), (x).end()",
            "#define rall(x) (x).rbegin(), (x).rend()",
            "#define trav(a, x) for (auto& a : x)",
            "#define make_unique(v) sort(all(v)), v.erase(unique(all(v)), v.end())",
            "#define F first",
            "#define S second",
            "#define pb push_back",
            "#define nl '\\n'",
            "#define inf (ll)1e18",
            "#define ya cout << \"YES\\n\"",
            "#define na cout << \"NO\\n\"",
            "#define imp cout << \"Impossible\\n\"",
            "",
            "#ifdef ONPC",
            "#include <bits/debug.h>",
            "#else",
            "#define dbg(...)",
            "#define dbgarr(...)",
            "#endif",
            "",
            "template <class T> using minpq = priority_queue<T, vector<T>, greater<T>>;",
            "template <class T> using maxpq = priority_queue<T>;",
            "template <class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template <class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }",
            "",
            "namespace fastio {",
            "const int mxn = 1 << 16;",
            "char buf[mxn], *S = NULL, *T = NULL;",
            "inline char Getchar()",
            "{",
            "    return (S == T ? T = (S = buf) + fread(buf, 1, mxn, stdin) : 0,",
            "        S == T ? EOF : *S++);",
            "}",
            "template <typename T> void read(T& x)",
            "{",
            "    x = 0;",
            "    char c = 0;",
            "    int f = 0;",
            "    for (c = Getchar(); c != EOF && (c < '0' || c > '9'); c = Getchar())",
            "        if (c == '-') f = 1;",
            "    while (c >= '0' && c <= '9') x = x * 10 + (c & 15), c = Getchar();",
            "    if (f) x = -x;",
            "}",
            "void read(string& s)",
            "{",
            "    char c = Getchar();",
            "    do {",
            "        s += c;",
            "        c = Getchar();",
            "    } while (c != '\\n' && c != ' ' && c != EOF);",
            "}",
            "template <typename T> void read(vector<T>& a)",
            "{",
            "    for (auto& x : a) read(x);",
            "}",
            "template <typename T, typename... _T> void read(T& x, _T&... y)",
            "{",
            "    read(x), read(y...);",
            "}",
            "}",
            "using fastio::read;",
            "",
            "template <typename T> ostream& operator<<(ostream& out, vector<T>& a)",
            "{",
            "    for (auto& x : a) out << x << ' ';",
            "    return out;",
            "};",
            "",
            "int solve()", 
			"{",
				"\t$1",
				"\treturn 0;",
			"}",
            "",
            "int32_t main()",
            "{",
            "    // sieve(2e5+10);",
            "    ios::sync_with_stdio(0), cin.tie(0);",
            "    int TET = 1;",
            "    read(TET);",
            "    for (int i = 1; i <= TET; i++) {",
            "        if (solve()) { break; }",
            "#ifdef ONPC",
            "        cerr << \"__________________________\\n\";",
            "#endif",
            "    }",
            "#ifdef ONPC",
            "    cerr << \"\\nfinished in \" << (ld)clock() / CLOCKS_PER_SEC << \" sec\\n\";",
            "#endif",
            "}"
        ],
        "description": "Snippet generated from template.cpp"
    },
    "sparse_table": {
        "prefix": "sparse_table",
        "body": [
            "template <typename T> struct SparseTable {",
            "    vector<vector<T>> sparse;",
            "    function<T(const T&, const T&)> accum_func;",
            "",
            "    SparseTable(",
            "        const vector<T>& arr, const function<T(const T&, const T&)>& func)",
            "        : accum_func(func)",
            "    {",
            "        int n = arr.size();",
            "        int logn = 32 - __builtin_clz(n);",
            "        sparse.resize(logn, vector<T>(n));",
            "        sparse[0] = arr;",
            "        for (int lg = 1; lg < logn; lg++) {",
            "            for (int i = 0; i + (1 << lg) <= n; i++) {",
            "                sparse[lg][i] = accum_func(",
            "                    sparse[lg - 1][i], sparse[lg - 1][i + (1 << (lg - 1))]);",
            "            }",
            "        }",
            "    }",
            "",
            "    T find(int l, int r)",
            "    { // [l, r)",
            "        int cur_log = 31 - __builtin_clz(r - l);",
            "        return accum_func(",
            "            sparse[cur_log][l], sparse[cur_log][r - (1 << cur_log)]);",
            "    }",
            "};",
            "// SparseTable<int> st(a, [](ll c, ll d) { return max(c, d); });"
        ],
        "description": "Snippet generated from sparse_table.cpp"
    },
    "fenwick2D": {
        "prefix": "fenwick2D",
        "body": [
            "struct Fenwick2D {",
            "    vector<vector<ll>> tree;",
            "    int n, m;",
            "",
            "    Fenwick2D(int n, int m)",
            "        : n(n)",
            "        , m(m)",
            "    {",
            "        tree.assign(n, vector<ll>(m, 0));",
            "    }",
            "",
            "    void point_add(int posx, int posy, ll val)",
            "    {",
            "        for (int x = posx; x < n; x |= (x + 1)) {",
            "            for (int y = posy; y < m; y |= (y + 1)) { tree[x][y] += val; }",
            "        }",
            "    }",
            "",
            "    ll find_sum(int rx, int ry)",
            "    { // [0, rx] x [0, ry]",
            "        ll ans = 0;",
            "        for (int x = rx; x >= 0; x = (x & (x + 1)) - 1) {",
            "            for (int y = ry; y >= 0; y = (y & (y + 1)) - 1) {",
            "                ans += tree[x][y];",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    ll find_sum(int lx, int rx, int ly, int ry)",
            "    { // [lx, rx) x [ly, ry)",
            "        return find_sum(rx - 1, ry - 1) - find_sum(rx - 1, ly - 1)",
            "            - find_sum(lx - 1, ry - 1) + find_sum(lx - 1, ly - 1);",
            "    }",
            "};"
        ],
        "description": "Snippet generated from fenwick2D.cpp"
    },
    "segment_tree": {
        "prefix": "segment_tree",
        "body": [
            "struct SegmentTree {",
            "    // TO CHANGE",
            "",
            "    struct Node { // set default values",
            "",
            "        ll va;",
            "        Node() { va = 0; }",
            "        template <typename T> void apply(int l, int r, T val)",
            "        { // update value and save push",
            "            va = val;",
            "        }",
            "    };",
            "",
            "    Node merge(const Node& left, const Node& right)",
            "    {",
            "        Node ans;",
            "        ans.va = max(left.va, right.va);",
            "        return ans;",
            "    }",
            "",
            "    // DEFAULT PART",
            "",
            "    vector<Node> tree;",
            "    int n;",
            "",
            "    template <typename T> void build(int v, int l, int r, const vector<T>& arr)",
            "    {",
            "        if (l + 1 == r) {",
            "            tree[v].apply(l, r, arr[l]);",
            "            return;",
            "        }",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        build(vl, l, mid, arr);",
            "        build(vr, mid, r, arr);",
            "        tree[v] = merge(tree[vl], tree[vr]);",
            "    }",
            "",
            "    void build(int v, int l, int r)",
            "    {",
            "        if (l + 1 == r) { return; }",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        build(vl, l, mid);",
            "        build(vr, mid, r);",
            "        tree[v] = merge(tree[vl], tree[vr]);",
            "    }",
            "",
            "    Node find(int v, int l, int r, int ql, int qr)",
            "    {",
            "        if (ql <= l && r <= qr) { return tree[v]; }",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        if (qr <= mid) {",
            "            return find(vl, l, mid, ql, qr);",
            "        } else if (ql >= mid) {",
            "            return find(vr, mid, r, ql, qr);",
            "        } else {",
            "            return merge(find(vl, l, mid, ql, qr), find(vr, mid, r, ql, qr));",
            "        }",
            "    }",
            "",
            "    template <typename T>",
            "    void update(int v, int l, int r, int ql, int qr, const T& newval)",
            "    {",
            "        if (ql <= l && r <= qr) {",
            "            tree[v].apply(l, r, newval);",
            "            return;",
            "        }",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        if (ql < mid) { update(vl, l, mid, ql, qr, newval); }",
            "        if (qr > mid) { update(vr, mid, r, ql, qr, newval); }",
            "        tree[v] = merge(tree[vl], tree[vr]);",
            "    }",
            "",
            "    int find_first(int v, int l, int r, int ql, int qr,",
            "        const function<bool(const Node&)>& predicate)",
            "    {",
            "        if (!predicate(tree[v])) { return -1; }",
            "        if (l + 1 == r) { return l; }",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        if (ql < mid) {",
            "            int lans = find_first(vl, l, mid, ql, qr, predicate);",
            "            if (lans != -1) { return lans; }",
            "        }",
            "        if (qr > mid) {",
            "            int rans = find_first(vr, mid, r, ql, qr, predicate);",
            "            if (rans != -1) { return rans; }",
            "        }",
            "        return -1;",
            "    }",
            "    int find_last(int v, int l, int r, int ql, int qr,",
            "        const function<bool(const Node&)>& predicate)",
            "    {",
            "        if (!predicate(tree[v])) { return -1; }",
            "        if (l + 1 == r) { return l; }",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        if (qr > mid) {",
            "            int rans = find_last(vr, mid, r, ql, qr, predicate);",
            "            if (rans != -1) { return rans; }",
            "        }",
            "        if (ql < mid) {",
            "            int lans = find_last(vl, l, mid, ql, qr, predicate);",
            "            if (lans != -1) { return lans; }",
            "        }",
            "        return -1;",
            "    }",
            "",
            "    // INTERFACE",
            "",
            "    SegmentTree(int n)",
            "        : n(n)",
            "    { // build from size with default values",
            "        tree.resize(2 * n - 1);",
            "        build(0, 0, n);",
            "    }",
            "",
            "    template <typename T> SegmentTree(const vector<T>& arr)",
            "    { // build from vector",
            "        n = sz(arr);",
            "        tree.resize(2 * n - 1);",
            "        build(0, 0, n, arr);",
            "    }",
            "",
            "    Node find(int ql, int qr)",
            "    { // find value on [ql, qr)",
            "        return find(0, 0, n, ql, qr);",
            "    }",
            "",
            "    Node find(int qi)",
            "    { // find value of position qi",
            "        return find(0, 0, n, qi, qi + 1);",
            "    }",
            "",
            "    template <typename T> void update(int ql, int qr, const T& newval)",
            "    { // update [ql, qr) with newval",
            "        update(0, 0, n, ql, qr, newval);",
            "    }",
            "",
            "    template <typename T> void update(int qi, const T& newval)",
            "    { // update position qi with newval",
            "        update(0, 0, n, qi, qi + 1, newval);",
            "    }",
            "",
            "    int find_first(int ql, int qr, const function<bool(const Node&)>& predicate)",
            "    { // find first index on [ql, qr) that satisfies predicate or -1 if none",
            "        return find_first(0, 0, n, ql, qr, predicate);",
            "    }",
            "",
            "    int find_first(int ql, const function<bool(const Node&)>& predicate)",
            "    { // find first index >= ql that satisfies predicate or -1 if none",
            "        return find_first(0, 0, n, ql, n, predicate);",
            "    }",
            "",
            "    int find_first(const function<bool(const Node&)>& predicate)",
            "    { // find first index that satisfies predicate or -1 if none",
            "        return find_first(0, 0, n, 0, n, predicate);",
            "    }",
            "    int find_last(int ql, int qr, const function<bool(const Node&)>& predicate)",
            "    { // find first index on [ql, qr) that satisfies predicate or -1 if none",
            "        return find_last(0, 0, n, ql, qr, predicate);",
            "    }",
            "",
            "    int find_last(int ql, const function<bool(const Node&)>& predicate)",
            "    { // find first index >= ql that satisfies predicate or -1 if none",
            "        return find_last(0, 0, n, ql, n, predicate);",
            "    }",
            "",
            "    int find_last(const function<bool(const Node&)>& predicate)",
            "    { // find first index that satisfies predicate or -1 if none",
            "        return find_last(0, 0, n, 0, n, predicate);",
            "    }",
            "};"
        ],
        "description": "Snippet generated from segment_tree.cpp"
    },
    "FFT": {
        "prefix": "FFT",
        "body": [
            "namespace fft {",
            "struct cmpl {",
            "    double x, y;",
            "    cmpl() { x = y = 0; }",
            "    cmpl(double x, double y)",
            "        : x(x)",
            "        , y(y)",
            "    {",
            "    }",
            "    inline cmpl conjugated() const { return cmpl(x, -y); }",
            "};",
            "inline cmpl operator+(cmpl a, cmpl b) { return cmpl(a.x + b.x, a.y + b.y); }",
            "inline cmpl operator-(cmpl a, cmpl b) { return cmpl(a.x - b.x, a.y - b.y); }",
            "inline cmpl operator*(cmpl a, cmpl b)",
            "{",
            "    return cmpl(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);",
            "}",
            "",
            "int base = 1; // current power of two (2^base >= n)",
            "vector<cmpl> roots = {",
            "    { 0, 0 }, { 1, 0 }",
            "}; // complex roots of 1 (with bases from 1 to base), 1-based indexing",
            "vector<int> rev = { 0, 1 }; // rev[i] = reversed bit representation of i",
            "const double PI = static_cast<double>(acosl(-1.0));",
            "",
            "void ensure_base(int nbase)",
            "{ // if base < nbase increase it",
            "    if (nbase <= base) { return; }",
            "    rev.resize(1 << nbase);",
            "    for (int i = 1; i < (1 << nbase); i++) {",
            "        rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));",
            "    }",
            "    roots.resize(1 << nbase);",
            "    while (base < nbase) {",
            "        double angle = 2 * PI / (1 << (base + 1));",
            "        for (int i = 1 << (base - 1); i < (1 << base); i++) {",
            "            roots[i << 1] = roots[i];",
            "            double angle_i = angle * (2 * i + 1 - (1 << base));",
            "            roots[(i << 1) + 1] = cmpl(cos(angle_i), sin(angle_i));",
            "        }",
            "        base++;",
            "    }",
            "}",
            "",
            "void fft(vector<cmpl>& a, int n = -1)",
            "{",
            "    if (n == -1) { n = (int)a.size(); }",
            "    assert((n & (n - 1)) == 0); // ensure that n is a power of two",
            "    int zeros = __builtin_ctz(n);",
            "    ensure_base(zeros);",
            "    int shift = base - zeros;",
            "    for (int i = 0; i < n; i++) {",
            "        if (i < (rev[i] >> shift)) { swap(a[i], a[rev[i] >> shift]); }",
            "    }",
            "    for (int k = 1; k < n; k <<= 1) {",
            "        for (int i = 0; i < n; i += 2 * k) {",
            "            for (int j = 0; j < k; j++) {",
            "                cmpl z = a[i + j + k] * roots[j + k];",
            "                a[i + j + k] = a[i + j] - z;",
            "                a[i + j] = a[i + j] + z;",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "vector<cmpl> fa, fb;",
            "",
            "vector<long long> square(const vector<int>& a)",
            "{",
            "    if (a.empty()) { return {}; }",
            "    int need = (int)a.size() + (int)a.size() - 1;",
            "    int nbase = 1;",
            "    while ((1 << nbase) < need) { nbase++; }",
            "    ensure_base(nbase);",
            "    int sz = 1 << nbase;",
            "    if ((sz >> 1) > (int)fa.size()) { fa.resize(sz >> 1); }",
            "    for (int i = 0; i < (sz >> 1); i++) {",
            "        int x = (2 * i < (int)a.size() ? a[2 * i] : 0);",
            "        int y = (2 * i + 1 < (int)a.size() ? a[2 * i + 1] : 0);",
            "        fa[i] = cmpl(x, y);",
            "    }",
            "    fft(fa, sz >> 1);",
            "    cmpl r(1.0 / (sz >> 1), 0.0);",
            "    for (int i = 0; i <= (sz >> 2); i++) {",
            "        int j = ((sz >> 1) - i) & ((sz >> 1) - 1);",
            "        cmpl fe = (fa[i] + fa[j].conjugated()) * cmpl(0.5, 0);",
            "        cmpl fo = (fa[i] - fa[j].conjugated()) * cmpl(0, -0.5);",
            "        cmpl aux",
            "            = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];",
            "        cmpl tmp = fe * fo;",
            "        fa[i] = r * (aux.conjugated() + cmpl(0, 2) * tmp.conjugated());",
            "        fa[j] = r * (aux + cmpl(0, 2) * tmp);",
            "    }",
            "    fft(fa, sz >> 1);",
            "    vector<long long> res(need);",
            "    for (int i = 0; i < need; i++) {",
            "        res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);",
            "    }",
            "    return res;",
            "}",
            "",
            "// interface",
            "",
            "vector<long long> multiply(const vector<int>& a, const vector<int>& b)",
            "{",
            "    if (a.empty() || b.empty()) { return {}; }",
            "    if (a == b) { return square(a); }",
            "    int need = (int)a.size() + (int)b.size() - 1;",
            "    int nbase = 1;",
            "    while ((1 << nbase) < need) nbase++;",
            "    ensure_base(nbase);",
            "    int sz = 1 << nbase;",
            "    if (sz > (int)fa.size()) { fa.resize(sz); }",
            "    for (int i = 0; i < sz; i++) {",
            "        int x = (i < (int)a.size() ? a[i] : 0);",
            "        int y = (i < (int)b.size() ? b[i] : 0);",
            "        fa[i] = cmpl(x, y);",
            "    }",
            "    fft(fa, sz);",
            "    cmpl r(0, -0.25 / (sz >> 1));",
            "    for (int i = 0; i <= (sz >> 1); i++) {",
            "        int j = (sz - i) & (sz - 1);",
            "        cmpl z = (fa[j] * fa[j] - (fa[i] * fa[i]).conjugated()) * r;",
            "        fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conjugated()) * r;",
            "        fa[i] = z;",
            "    }",
            "    for (int i = 0; i < (sz >> 1); i++) {",
            "        cmpl A0 = (fa[i] + fa[i + (sz >> 1)]) * cmpl(0.5, 0);",
            "        cmpl A1",
            "            = (fa[i] - fa[i + (sz >> 1)]) * cmpl(0.5, 0) * roots[(sz >> 1) + i];",
            "        fa[i] = A0 + A1 * cmpl(0, 1);",
            "    }",
            "    fft(fa, sz >> 1);",
            "    vector<long long> res(need);",
            "    for (int i = 0; i < need; i++) {",
            "        res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);",
            "    }",
            "    return res;",
            "}",
            "",
            "vector<int> multiply_mod(const vector<int>& a, const vector<int>& b, int m)",
            "{",
            "    if (a.empty() || b.empty()) { return {}; }",
            "    int need = (int)a.size() + (int)b.size() - 1;",
            "    int nbase = 0;",
            "    while ((1 << nbase) < need) { nbase++; }",
            "    ensure_base(nbase);",
            "    int sz = 1 << nbase;",
            "    if (sz > (int)fa.size()) { fa.resize(sz); }",
            "    for (int i = 0; i < (int)a.size(); i++) {",
            "        int x = (a[i] % m + m) % m;",
            "        fa[i] = cmpl(x & ((1 << 15) - 1), x >> 15);",
            "    }",
            "    fill(fa.begin() + a.size(), fa.begin() + sz, cmpl { 0, 0 });",
            "    fft(fa, sz);",
            "    if (sz > (int)fb.size()) { fb.resize(sz); }",
            "    if (a == b) {",
            "        copy(fa.begin(), fa.begin() + sz, fb.begin());",
            "    } else {",
            "        for (int i = 0; i < (int)b.size(); i++) {",
            "            int x = (b[i] % m + m) % m;",
            "            fb[i] = cmpl(x & ((1 << 15) - 1), x >> 15);",
            "        }",
            "        fill(fb.begin() + b.size(), fb.begin() + sz, cmpl { 0, 0 });",
            "        fft(fb, sz);",
            "    }",
            "    double ratio = 0.25 / sz;",
            "    cmpl r2(0, -1);",
            "    cmpl r3(ratio, 0);",
            "    cmpl r4(0, -ratio);",
            "    cmpl r5(0, 1);",
            "    for (int i = 0; i <= (sz >> 1); i++) {",
            "        int j = (sz - i) & (sz - 1);",
            "        cmpl a1 = (fa[i] + fa[j].conjugated());",
            "        cmpl a2 = (fa[i] - fa[j].conjugated()) * r2;",
            "        cmpl b1 = (fb[i] + fb[j].conjugated()) * r3;",
            "        cmpl b2 = (fb[i] - fb[j].conjugated()) * r4;",
            "        if (i != j) {",
            "            cmpl c1 = (fa[j] + fa[i].conjugated());",
            "            cmpl c2 = (fa[j] - fa[i].conjugated()) * r2;",
            "            cmpl d1 = (fb[j] + fb[i].conjugated()) * r3;",
            "            cmpl d2 = (fb[j] - fb[i].conjugated()) * r4;",
            "            fa[i] = c1 * d1 + c2 * d2 * r5;",
            "            fb[i] = c1 * d2 + c2 * d1;",
            "        }",
            "        fa[j] = a1 * b1 + a2 * b2 * r5;",
            "        fb[j] = a1 * b2 + a2 * b1;",
            "    }",
            "    fft(fa, sz);",
            "    fft(fb, sz);",
            "    vector<int> res(need);",
            "    for (int i = 0; i < need; i++) {",
            "        long long aa = llround(fa[i].x);",
            "        long long bb = llround(fb[i].x);",
            "        long long cc = llround(fa[i].y);",
            "        res[i]",
            "            = static_cast<int>((aa + ((bb % m) << 15) + ((cc % m) << 30)) % m);",
            "    }",
            "    return res;",
            "}",
            "} // namespace fft",
            "/*",
            "use these:",
            "vector<int> multiply_mod(const vector<int>& a, const vector<int>& b, int m)",
            "vector<ll> square(const vector<int>& a)",
            "vector<ll> multiply(const vector<int>& a, const vector<int>& b) // (if a == b it",
            "uses square)",
            "*/"
        ],
        "description": "Snippet generated from FFT.cpp"
    },
    "DSU": {
        "prefix": "DSU",
        "body": [
            "struct DSU {",
            "    vector<int> pr;",
            "    vector<int> size;",
            "    int n;",
            "",
            "    DSU(int n)",
            "        : n(n)",
            "    {",
            "        pr.resize(n);",
            "        size.resize(n);",
            "        iota(pr.begin(), pr.end(), 0);",
            "        for_each(size.begin(), size.end(), [](int& x) { x = 1; });",
            "    }",
            "",
            "    inline int findpr(int v)",
            "    {",
            "        return (v == pr[v] ? v : (pr[v] = findpr(pr[v])));",
            "    }",
            "",
            "    inline bool check(int a, int b) { return findpr(a) == findpr(b); }",
            "",
            "    inline bool unite(int v, int u)",
            "    {",
            "        v = findpr(v);",
            "        u = findpr(u);",
            "        if (u == v) {",
            "            return false;",
            "        } else {",
            "            if (size[v] > size[u]) swap(u, v);",
            "            size[u] += size[v];",
            "            pr[v] = u;",
            "            return true;",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet generated from DSU.cpp"
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "vector<int> smallest_factor;",
            "vector<bool> prime;",
            "vector<int> primes;",
            "",
            "void sieve(int maximum)",
            "{",
            "    maximum = max(maximum, 1);",
            "    smallest_factor.assign(maximum + 1, 0);",
            "    prime.assign(maximum + 1, true);",
            "    prime[0] = prime[1] = false;",
            "    primes = {};",
            "",
            "    for (int p = 2; p <= maximum; p++)",
            "        if (prime[p]) {",
            "            smallest_factor[p] = p;",
            "            primes.push_back(p);",
            "",
            "            for (int64_t i = int64_t(p) * p; i <= maximum; i += p)",
            "                if (prime[i]) {",
            "                    prime[i] = false;",
            "                    smallest_factor[i] = p;",
            "                }",
            "        }",
            "}",
            "",
            "// Prime factorizes n in worst case O(sqrt n / log n). Requires having run",
            "// `sieve` up to at least sqrt(n). If we've run `sieve` up to at least n,",
            "// takes O(log n) time.",
            "vector<pair<int64_t, int>> prime_factorize(int64_t n)",
            "{",
            "    int64_t sieve_max = int64_t(smallest_factor.size()) - 1;",
            "    assert(1 <= n && n <= sieve_max * sieve_max);",
            "    vector<pair<int64_t, int>> result;",
            "",
            "    if (n <= sieve_max) {",
            "        while (n != 1) {",
            "            int64_t p = smallest_factor[n];",
            "            int exponent = 0;",
            "",
            "            do {",
            "                n /= p;",
            "                exponent++;",
            "            } while (n % p == 0);",
            "",
            "            result.emplace_back(p, exponent);",
            "        }",
            "",
            "        return result;",
            "    }",
            "",
            "    for (int64_t p : primes) {",
            "        if (p * p > n) break;",
            "",
            "        if (n % p == 0) {",
            "            result.emplace_back(p, 0);",
            "",
            "            do {",
            "                n /= p;",
            "                result.back().second++;",
            "            } while (n % p == 0);",
            "        }",
            "    }",
            "",
            "    if (n > 1) result.emplace_back(n, 1);",
            "",
            "    return result;",
            "}"
        ],
        "description": "Snippet generated from sieve.cpp"
    },
    "aho-corasik": {
        "prefix": "aho-corasik",
        "body": [
            "struct aho {",
            "    vector<vector<int>> g, gr;",
            "    vector<string> str;",
            "    int root;",
            "    int sz;",
            "    vector<ll> ending;",
            "    vector<int> link;",
            "    char firstlet;",
            "    int numlet = 0;",
            "",
            "    aho()",
            "        : g()",
            "        , gr()",
            "        , str()",
            "        , root(0)",
            "        , sz(0)",
            "        , ending()",
            "        , link()",
            "    {",
            "    }",
            "",
            "    aho(vector<string> q, char firlet = 'a')",
            "    { // change",
            "        firstlet = firlet;",
            "        sz = q.size();",
            "        str = q;",
            "        g.clear();",
            "        gr.clear();",
            "        ending.clear();",
            "        link.clear();",
            "        root = 0;",
            "        ending.assign(1, 0);",
            "        numlet = 0;",
            "        for (int i = 0; i < q.size(); i++) {",
            "            for (int j = 0; j < q[i].size(); j++) {",
            "                numlet = q[i][j] - firstlet;",
            "            }",
            "        }",
            "        numlet++;",
            "        g.push_back(vector<int>(numlet, -1));",
            "        for (int i = 0; i < q.size(); i++) {",
            "            int v = root;",
            "            for (int j = 0; j < q[i].size(); j++) {",
            "                if (g[v][q[i][j] - firstlet] == -1) {",
            "                    g[v][q[i][j] - firstlet] = g.size();",
            "                    g.push_back(vector<int>(numlet, -1));",
            "                    ending.push_back(0);",
            "                }",
            "                v = g[v][q[i][j] - firstlet];",
            "            }",
            "            ending[v]++;",
            "        }",
            "        link.assign(g.size(), -1);",
            "        link[root] = root;",
            "        queue<int> que;",
            "        que.push(root);",
            "        while (que.size()) {",
            "            int v = que.front();",
            "            que.pop();",
            "            for (int i = 0; i < numlet; i++) {",
            "                if (g[v][i] == -1) {",
            "                    if (v == root) {",
            "                        g[v][i] = v;",
            "                    } else {",
            "                        g[v][i] = g[link[v]][i];",
            "                    }",
            "                } else {",
            "                    que.push(g[v][i]);",
            "                    if (v == root) {",
            "                        link[g[v][i]] = v;",
            "                    } else {",
            "                        link[g[v][i]] = g[link[v]][i];",
            "                    }",
            "                }",
            "            }",
            "            gr.resize(g.size());",
            "            for (int i = 0; i < g.size(); i++) {",
            "                if (i != root) { gr[link[i]].push_back(i); }",
            "            }",
            "            dfslink(root);",
            "        }",
            "    }",
            "",
            "    void dfslink(int v)",
            "    {",
            "        for (int u : gr[v]) {",
            "            ending[u] += ending[v];",
            "            dfslink(u);",
            "        }",
            "    }",
            "",
            "    ll find(string s)",
            "    { // change",
            "        ll ans = 0;",
            "        int v = root;",
            "        for (int i = 0; i < s.size(); i++) {",
            "            v = g[v][s[i] - firstlet];",
            "            ans += ending[v];",
            "        }",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Snippet generated from aho-corasik.cpp"
    },
    "inv": {
        "prefix": "inv",
        "body": [
            "",
            "ll inv(ll a, ll m)",
            "{",
            "    if (a == 1) { return 1; }",
            "    return (1LL - inv(m % a, a) * m) / a + m;",
            "}"
        ],
        "description": "Snippet generated from inv.cpp"
    },
    "string_hassing": {
        "prefix": "string_hassing",
        "body": [
            "#define MAXLEN 1000010",
            "",
            "constexpr uint64_t mod = (1ULL << 61) - 1;",
            "",
            "const uint64_t seed = chrono::system_clock::now().time_since_epoch().count();",
            "const uint64_t base = mt19937_64(seed)() % (mod / 3) + (mod / 3);",
            "",
            "uint64_t base_pow[MAXLEN];",
            "",
            "int64_t modmul(uint64_t a, uint64_t b)",
            "{",
            "    uint64_t l1 = (uint32_t)a, h1 = a >> 32, l2 = (uint32_t)b, h2 = b >> 32;",
            "    uint64_t l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;",
            "    uint64_t ret",
            "        = (l & mod) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;",
            "    ret = (ret & mod) + (ret >> 61);",
            "    ret = (ret & mod) + (ret >> 61);",
            "    return ret - 1;",
            "}",
            "",
            "void init()",
            "{",
            "    base_pow[0] = 1;",
            "    for (int i = 1; i < MAXLEN; i++) {",
            "        base_pow[i] = modmul(base_pow[i - 1], base);",
            "    }",
            "}",
            "",
            "struct PolyHash {",
            "    /// Remove suff vector and usage if reverse hash is not required for more",
            "    /// speed",
            "    vector<int64_t> pref, suff;",
            "",
            "    PolyHash() { }",
            "",
            "    template <typename T> PolyHash(const vector<T>& ar)",
            "    {",
            "        if (!base_pow[0]) init();",
            "",
            "        int n = ar.size();",
            "        assert(n < MAXLEN);",
            "        pref.resize(n + 3, 0), suff.resize(n + 3, 0);",
            "",
            "        for (int i = 1; i <= n; i++) {",
            "            pref[i] = modmul(pref[i - 1], base) + ar[i - 1] + 997;",
            "            if (pref[i] >= mod) pref[i] -= mod;",
            "        }",
            "",
            "        for (int i = n; i >= 1; i--) {",
            "            suff[i] = modmul(suff[i + 1], base) + ar[i - 1] + 997;",
            "            if (suff[i] >= mod) suff[i] -= mod;",
            "        }",
            "    }",
            "",
            "    PolyHash(const char* str)",
            "        : PolyHash(vector<char>(str, str + strlen(str)))",
            "    {",
            "    }",
            "",
            "    uint64_t get_hash(int l, int r)",
            "    {",
            "        int64_t h = pref[r + 1] - modmul(base_pow[r - l + 1], pref[l]);",
            "        return h < 0 ? h + mod : h;",
            "    }",
            "",
            "    uint64_t rev_hash(int l, int r)",
            "    {",
            "        int64_t h = suff[l + 1] - modmul(base_pow[r - l + 1], suff[r + 2]);",
            "        return h < 0 ? h + mod : h;",
            "    }",
            "};"
        ],
        "description": "Snippet generated from string_hassing.cpp"
    },
    "Lazy_seg_tree": {
        "prefix": "Lazy_seg_tree",
        "body": [
            "/*",
            "problem : https://cses.fi/problemset/task/1651/",
            "*/",
            "struct SegmentTree {",
            "    // TO CHANGE",
            "",
            "    struct Node { // set default values",
            "",
            "        ll va;",
            "        ll push;",
            "        Node()",
            "        {",
            "            va = 0;",
            "            push = 0;",
            "        }",
            "        template <typename T> void apply(int l, int r, T val)",
            "        { // update value and save push",
            "            va += val;",
            "            push += val;",
            "            if (l == r + 1) { push = 0; }",
            "        }",
            "    };",
            "",
            "    Node merge(const Node& left, const Node& right)",
            "    {",
            "        Node ans;",
            "        ans.va = max(left.va, right.va);",
            "        return ans;",
            "    }",
            "",
            "    void push(int v, int l, int r)",
            "    {",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        tree[vl].apply(l, mid, tree[v].push);",
            "        tree[vr].apply(mid, r, tree[v].push);",
            "        tree[v].push = 0;",
            "        return;",
            "    }",
            "",
            "    // DEFAULT PART",
            "",
            "    vector<Node> tree;",
            "    int n;",
            "",
            "    template <typename T> void build(int v, int l, int r, const vector<T>& arr)",
            "    {",
            "        if (l + 1 == r) {",
            "            tree[v].apply(l, r, arr[l]);",
            "            return;",
            "        }",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        build(vl, l, mid, arr);",
            "        build(vr, mid, r, arr);",
            "        tree[v] = merge(tree[vl], tree[vr]);",
            "    }",
            "",
            "    void build(int v, int l, int r)",
            "    {",
            "        if (l + 1 == r) { return; }",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        build(vl, l, mid);",
            "        build(vr, mid, r);",
            "        tree[v] = merge(tree[vl], tree[vr]);",
            "    }",
            "",
            "    Node find(int v, int l, int r, int ql, int qr)",
            "    {",
            "        if (ql <= l && r <= qr) { return tree[v]; }",
            "        push(v, l, r);",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        if (qr <= mid) {",
            "            return find(vl, l, mid, ql, qr);",
            "        } else if (ql >= mid) {",
            "            return find(vr, mid, r, ql, qr);",
            "        } else {",
            "            return merge(find(vl, l, mid, ql, qr), find(vr, mid, r, ql, qr));",
            "        }",
            "    }",
            "",
            "    template <typename T>",
            "    void update(int v, int l, int r, int ql, int qr, const T& newval)",
            "    {",
            "        if (ql <= l && r <= qr) {",
            "            tree[v].apply(l, r, newval);",
            "            return;",
            "        }",
            "        push(v, l, r);",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        if (ql < mid) { update(vl, l, mid, ql, qr, newval); }",
            "        if (qr > mid) { update(vr, mid, r, ql, qr, newval); }",
            "        tree[v] = merge(tree[vl], tree[vr]);",
            "    }",
            "",
            "    int find_first(int v, int l, int r, int ql, int qr,",
            "        const function<bool(const Node&)>& predicate)",
            "    {",
            "        if (!predicate(tree[v])) { return -1; }",
            "        if (l + 1 == r) { return l; }",
            "        push(v, l, r);",
            "        int mid = (r + l) >> 1;",
            "        int vl = v + 1, vr = v + ((mid - l) << 1);",
            "        if (ql < mid) {",
            "            int lans = find_first(vl, l, mid, ql, qr, predicate);",
            "            if (lans != -1) { return lans; }",
            "        }",
            "        if (qr > mid) {",
            "            int rans = find_first(vr, mid, r, ql, qr, predicate);",
            "            if (rans != -1) { return rans; }",
            "        }",
            "        return -1;",
            "    }",
            "",
            "    // INTERFACE",
            "",
            "    SegmentTree(int n)",
            "        : n(n)",
            "    { // build from size with default values",
            "        tree.resize(2 * n - 1);",
            "        build(0, 0, n);",
            "    }",
            "",
            "    template <typename T> SegmentTree(const vector<T>& arr)",
            "    { // build from vector",
            "        n = sz(arr);",
            "        tree.resize(2 * n - 1);",
            "        build(0, 0, n, arr);",
            "    }",
            "",
            "    Node find(int ql, int qr)",
            "    { // find value on [ql, qr)",
            "        return find(0, 0, n, ql, qr);",
            "    }",
            "",
            "    Node find(int qi)",
            "    { // find value of position qi",
            "        return find(0, 0, n, qi, qi + 1);",
            "    }",
            "",
            "    template <typename T> void update(int ql, int qr, const T& newval)",
            "    { // update [ql, qr) with newval",
            "        update(0, 0, n, ql, qr, newval);",
            "    }",
            "",
            "    template <typename T> void update(int qi, const T& newval)",
            "    { // update position qi with newval",
            "        update(0, 0, n, qi, qi + 1, newval);",
            "    }",
            "",
            "    int find_first(int ql, int qr, const function<bool(const Node&)>& predicate)",
            "    { // find first index on [ql, qr) that satisfies predicate or -1 if none",
            "        return find_first(0, 0, n, ql, qr, predicate);",
            "    }",
            "",
            "    int find_first(int ql, const function<bool(const Node&)>& predicate)",
            "    { // find first index >= ql that satisfies predicate or -1 if none",
            "        return find_first(0, 0, n, ql, n, predicate);",
            "    }",
            "",
            "    int find_first(const function<bool(const Node&)>& predicate)",
            "    { // find first index that satisfies predicate or -1 if none",
            "        return find_first(0, 0, n, 0, n, predicate);",
            "    }",
            "};"
        ],
        "description": "Snippet generated from Lazy_seg_tree.cpp"
    },
    "prefix_sum": {
        "prefix": "prefix_sum",
        "body": [
            "struct PrefixSum {",
            "    vector<ll> pref;",
            "    PrefixSum(vector<ll>& a)",
            "    {",
            "        pref.resize(sz(a) + 1);",
            "        pref[0] = 0;",
            "        for (int i = 0; i < sz(a); i++) { pref[i + 1] = pref[i] + a[i]; }",
            "    }",
            "",
            "    ll get(int l, int r) // [l, r)",
            "    {",
            "        return pref[r] - pref[l];",
            "    }",
            "};"
        ],
        "description": "Snippet generated from prefix_sum.cpp"
    },
    "gcd": {
        "prefix": "gcd",
        "body": [
            "template <typename T> T gcd(T a, T b)",
            "{",
            "    while (a) {",
            "        b %= a;",
            "        swap(a, b);",
            "    }",
            "    return b;",
            "}"
        ],
        "description": "Snippet generated from gcd.cpp"
    },
    "treap": {
        "prefix": "treap",
        "body": [
            "struct Node {",
            "    int x;",
            "    ll y;",
            "    int sz;",
            "    Node* left;",
            "    Node* right;",
            "    Node(int x = 0)",
            "        : x(x)",
            "        , y((ll)rnd())",
            "        , sz(1)",
            "        , left(NULL)",
            "        , right(NULL)",
            "    {",
            "    }",
            "};",
            "",
            "int sz(Node* v) { return (v == NULL ? 0 : v->sz); }",
            "",
            "Node* upd(Node* v)",
            "{",
            "    if (v != NULL) { v->sz = 1 + sz(v->left) + sz(v->right); }",
            "    return v;",
            "}",
            "",
            "Node* merge(Node* l, Node* r)",
            "{",
            "    if (l == NULL) { return r; }",
            "    if (r == NULL) { return l; }",
            "    if (l->y < r->y) {",
            "        l = merge(l, r->left);",
            "        r->left = l;",
            "        r = upd(r);",
            "        return r;",
            "    }",
            "    r = merge(l->right, r);",
            "    l->right = r;",
            "    l = upd(l);",
            "    return l;",
            "}",
            "",
            "pair<Node*, Node*> keySplit(Node* v, int key)",
            "{ // l's keys <= key, r's keys > key",
            "    if (v == NULL) { return { v, v }; }",
            "    if (v->x <= key) {",
            "        auto a = keySplit(v->right, key);",
            "        v->right = a.first;",
            "        v = upd(v);",
            "        return { v, a.second };",
            "    }",
            "    auto a = keySplit(v->left, key);",
            "    v->left = a.second;",
            "    v = upd(v);",
            "    return { a.first, v };",
            "}",
            "",
            "pair<Node*, Node*> sizeSplit(Node* v, int siz)",
            "{ // l's size is siz",
            "    if (!v) { return { v, v }; }",
            "    if (sz(v->left) >= siz) {",
            "        auto a = sizeSplit(v->left, siz);",
            "        v->left = a.second;",
            "        v = upd(v);",
            "        return { a.first, v };",
            "    }",
            "    auto a = sizeSplit(v->right, siz - sz(v->left) - 1);",
            "    v->right = a.first;",
            "    v = upd(v);",
            "    return { v, a.second };",
            "}",
            "",
            "void gogo(Node* v)",
            "{",
            "    if (v == NULL) { return; }",
            "    gogo(v->left);",
            "    cerr << v->x << endl;",
            "    gogo(v->right);",
            "}"
        ],
        "description": "Snippet generated from treap.cpp"
    },
    "centroid_decomp": {
        "prefix": "centroid_decomp",
        "body": [
            "const int MAXN = ;",
            "",
            "vector<int> g[MAXN], used, p, d;",
            "",
            "int cnt;",
            "",
            "int dfs(int v, int pr)",
            "{",
            "    cnt++;",
            "    d[v] = 1;",
            "    for (int u : g[v]) {",
            "        if (!used[u] && u != pr) { d[v] += dfs(u, v); }",
            "    }",
            "    return d[v];",
            "}",
            "",
            "int centroid(int v)",
            "{",
            "    cnt = 0;",
            "    dfs(v, -1);",
            "    int pr = -1;",
            "    while (true) {",
            "        int z = -1;",
            "        for (int u : g[v]) {",
            "            if (!used[u] && u != pr && d[u] * 2 >= cnt) { z = u; }",
            "        }",
            "        if (z == -1) { break; }",
            "        pr = v;",
            "        v = z;",
            "    }",
            "    return v;",
            "}",
            "",
            "void go(int v, int pr)",
            "{",
            "    v = centroid(v);",
            "    p[v] = pr;",
            "    used[v] = 1;",
            "",
            "    for (int u : g[v]) {",
            "        if (!used[u]) { go(u, v); }",
            "    }",
            "}"
        ],
        "description": "Snippet generated from centroid_decomp.cpp"
    },
    "binpow": {
        "prefix": "binpow",
        "body": [
            "template <typename T> T binpow(T a, T b)",
            "{",
            "    T ans = 1;",
            "    while (b) {",
            "        if (b & 1) { ans = 1LL * ans * a % MOD; }",
            "        a = 1LL * a * a % MOD;",
            "        b >>= 1;",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "Snippet generated from binpow.cpp"
    },
    "Modular": {
        "prefix": "Modular",
        "body": [
            "template <int MODULO> struct ModularInt {",
            "    int value;",
            "    ModularInt(ll llvalue)",
            "        : value(llvalue % MODULO)",
            "    {",
            "        if (value < 0) value += MODULO;",
            "    }",
            "    ModularInt(const ModularInt<MODULO>& other)",
            "        : value(other.value)",
            "    {",
            "    }",
            "    ModularInt()",
            "        : value(0)",
            "    {",
            "    }",
            "    inline void operator+=(ModularInt<MODULO> other)",
            "    {",
            "        value += other.value;",
            "        if (value >= MODULO) value -= MODULO;",
            "    }",
            "    inline ModularInt<MODULO> operator+(ModularInt<MODULO> other) const",
            "    {",
            "        return ModularInt<MODULO>(value + other.value >= MODULO",
            "                ? value + other.value - MODULO",
            "                : value + other.value);",
            "    }",
            "    inline void operator-=(ModularInt<MODULO> other)",
            "    {",
            "        value -= other.value;",
            "        if (value < 0) { value += MODULO; }",
            "    }",
            "    inline ModularInt<MODULO> operator-(ModularInt<MODULO> other) const",
            "    {",
            "        return ModularInt<MODULO>(value - other.value < 0",
            "                ? value - other.value + MODULO",
            "                : value - other.value);",
            "    }",
            "    inline ModularInt<MODULO> operator-() const",
            "    {",
            "        return ModularInt<MODULO>(value == 0 ? value : MODULO - value);",
            "    }",
            "    inline ModularInt<MODULO>& operator++()",
            "    {",
            "        ++value;",
            "        if (value == MODULO) { value = 0; }",
            "        return *this;",
            "    }",
            "    inline ModularInt<MODULO> operator++(int)",
            "    {",
            "        ModularInt<MODULO> old(*this);",
            "        ++value;",
            "        if (value == MODULO) { value = 0; }",
            "        return old;",
            "    }",
            "    inline ModularInt<MODULO>& operator--()",
            "    {",
            "        --value;",
            "        if (value == -1) { value = MODULO - 1; }",
            "        return *this;",
            "    }",
            "    inline ModularInt<MODULO> operator--(int)",
            "    {",
            "        ModularInt<MODULO> old(*this);",
            "        --value;",
            "        if (value == -1) { value = MODULO - 1; }",
            "        return old;",
            "    }",
            "    inline ModularInt<MODULO> operator*(ModularInt<MODULO> other) const",
            "    {",
            "        return ModularInt<MODULO>(1LL * value * other.value);",
            "    }",
            "    inline void operator*=(ModularInt<MODULO> other)",
            "    {",
            "        value = 1LL * value * other.value % MODULO;",
            "    }",
            "    friend ModularInt<MODULO> binpow(ModularInt<MODULO> a, ll bll)",
            "    {",
            "        if (a.value == 0) { return ModularInt<MODULO>(bll == 0 ? 1 : 0); }",
            "        int b = bll % (MODULO - 1);",
            "        int ans = 1;",
            "        while (b) {",
            "            if (b & 1) { ans = 1LL * ans * a.value % MODULO; }",
            "            a.value = 1LL * a.value * a.value % MODULO;",
            "            b >>= 1;",
            "        }",
            "        return ModularInt<MODULO>(ans);",
            "    }",
            "    inline ModularInt<MODULO> inv() const { return binpow(*this, MODULO - 2); }",
            "    inline ModularInt<MODULO> operator/(ModularInt<MODULO> other) const",
            "    {",
            "        return (*this) * other.inv();",
            "    }",
            "    inline void operator/=(ModularInt<MODULO> other)",
            "    {",
            "        value = 1LL * value * other.inv().value % MODULO;",
            "    }",
            "    inline bool operator==(ModularInt<MODULO> other) const",
            "    {",
            "        return value == other.value;",
            "    }",
            "    inline bool operator!=(ModularInt<MODULO> other) const",
            "    {",
            "        return value != other.value;",
            "    }",
            "    explicit operator int() const { return value; }",
            "    explicit operator bool() const { return value; }",
            "    explicit operator long long() const { return value; }",
            "    friend istream& operator>>(istream& inp, ModularInt<MODULO>& mint)",
            "    {",
            "        inp >> mint.value;",
            "        return inp;",
            "    }",
            "    friend ostream& operator<<(ostream& out, const ModularInt<MODULO>& mint)",
            "    {",
            "        out << mint.value;",
            "        return out;",
            "    }",
            "};",
            "const int MOD = 1000000007;",
            "",
            "typedef ModularInt<MOD> mint;",
            "vector<mint> fact(1, 1);",
            "vector<mint> inv_fact(1, 1);",
            "",
            "mint C(int n, int k)",
            "{",
            "    if (k < 0 || k > n) { return 0; }",
            "    mint t = 1;",
            "    while ((int)fact.size() < n + 1) {",
            "        fact.push_back(fact.back() * (int)fact.size());",
            "        inv_fact.push_back(t / fact.back());",
            "    }",
            "    return fact[n] * inv_fact[k] * inv_fact[n - k];",
            "}"
        ],
        "description": "Snippet generated from Modular.cpp"
    },
    "kth_smallest_sum": {
        "prefix": "kth_smallest_sum",
        "body": [
            "struct sum_kth_smallest {",
            "",
            "    struct Node {",
            "        long long sum;",
            "        long long cnt;",
            "        long long lCh, rCh; // children, indexes into `tree`",
            "    };",
            "",
            "    long long mn, mx;",
            "    vector<long long> roots;",
            "    deque<Node> tree;",
            "",
            "    sum_kth_smallest(const vector<long long>& arr)",
            "        : mn(-1e18)",
            "        , mx(1e18)",
            "        , roots(arr.size() + 1, 0)",
            "    {",
            "        tree.push_back({ 0, 0, 0 }); // acts as null",
            "        for (long long val : arr)",
            "            mn = min(mn, val), mx = max(mx, val);",
            "        for (long long i = 0; i < (long long)arr.size(); i++)",
            "            roots[i + 1] = update(roots[i], -mx, mx, arr[i]);",
            "    }",
            "    long long update(long long v, long long tl, long long tr, long long idx)",
            "    {",
            "        if (tl == tr) {",
            "            tree.push_back({ tree[v].sum + tl, tree[v].cnt + 1, 0, 0 });",
            "            return tree.size() - 1;",
            "        }",
            "        long long tm = tl + (tr - tl) / 2;",
            "        long long lCh = tree[v].lCh;",
            "        long long rCh = tree[v].rCh;",
            "        if (idx <= tm)",
            "            lCh = update(lCh, tl, tm, idx);",
            "        else",
            "            rCh = update(rCh, tm + 1, tr, idx);",
            "        tree.push_back({ tree[lCh].sum + tree[rCh].sum,",
            "            tree[lCh].cnt + tree[rCh].cnt, lCh, rCh });",
            "        return tree.size() - 1;",
            "    }",
            "",
            "    /* find kth smallest number among arr[l], arr[l+1], ..., arr[r]",
            "     * k is 1-based, so find_kth(l,r,1) returns the min",
            "     */",
            "    long long query(long long l, long long r, long long k) const",
            "    {",
            "        assert(1 <= k && k <= r - l + 1); // note this condition implies L <= R",
            "        assert(0 <= l && r + 1 < (long long)roots.size());",
            "        return query(roots[l], roots[r + 1], -mx, mx, k);",
            "    }",
            "    long long query(long long vl, long long vr, long long tl, long long tr,",
            "        long long k) const",
            "    {",
            "        if (tl == tr)",
            "            return tl;",
            "        long long tm = tl + (tr - tl) / 2;",
            "        long long left_count = tree[tree[vr].lCh].cnt - tree[tree[vl].lCh].cnt;",
            "        if (left_count >= k)",
            "            return query(tree[vl].lCh, tree[vr].lCh, tl, tm, k);",
            "        return query(tree[vl].rCh, tree[vr].rCh, tm + 1, tr, k - left_count);",
            "    }",
            "",
            "    /* find **sum** of k smallest numbers among arr[l], arr[l+1], ..., arr[r]",
            "     * k is 1-based, so find_kth(l,r,1) returns the min",
            "     */",
            "    long long query_sum(long long l, long long r, long long k) const",
            "    {",
            "        assert(1 <= k && k <= r - l + 1); // note this condition implies L <= R",
            "        assert(0 <= l && r + 1 < (long long)roots.size());",
            "        return query_sum(roots[l], roots[r + 1], -mx, mx, k);",
            "    }",
            "    long long query_sum(long long vl, long long vr, long long tl, long long tr,",
            "        long long k) const",
            "    {",
            "        if (tl == tr)",
            "            return 1LL * tl * k;",
            "        long long tm = tl + (tr - tl) / 2;",
            "        long long left_count = tree[tree[vr].lCh].cnt - tree[tree[vl].lCh].cnt;",
            "        long long left_sum = tree[tree[vr].lCh].sum - tree[tree[vl].lCh].sum;",
            "        if (left_count >= k)",
            "            return query_sum(tree[vl].lCh, tree[vr].lCh, tl, tm, k);",
            "        return left_sum + query_sum(tree[vl].rCh, tree[vr].rCh, tm + 1, tr, k - left_count);",
            "    }",
            "}"
        ],
        "description": "Snippet generated from kth_smallest_sum.cpp"
    },
    "fenwick": {
        "prefix": "fenwick",
        "body": [
            "struct Fenwick {",
            "    vector<ll> tree;",
            "    int n;",
            "",
            "    Fenwick(int n)",
            "        : n(n)",
            "    {",
            "        tree.assign(n, 0);",
            "    }",
            "",
            "    void point_add(int pos, ll val)",
            "    {",
            "        for (; pos < n; pos |= (pos + 1)) { tree[pos] += val; }",
            "    }",
            "",
            "    ll find_sum(int r)",
            "    { // [0, r]",
            "        ll ans = 0;",
            "        for (; r >= 0; r = (r & (r + 1)) - 1) { ans += tree[r]; }",
            "        return ans;",
            "    }",
            "",
            "    ll find_sum(int l, int r)",
            "    { // [l, r)",
            "        return find_sum(r - 1) - find_sum(l - 1);",
            "    }",
            "};"
        ],
        "description": "Snippet generated from fenwick.cpp"
    },
    "z_function": {
        "prefix": "z_function",
        "body": [
            "/*",
            " * https://cp-algorithms.com/string/z-function.html",
            " */",
            "vector<int> z_function(string s)",
            "{",
            "    int n = s.size();",
            "    vector<int> z(n);",
            "    int l = 0, r = 0;",
            "    for (int i = 1; i < n; i++) {",
            "        if (i < r) { z[i] = min(r - i, z[i - l]); }",
            "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) { z[i]++; }",
            "        if (i + z[i] > r) {",
            "            l = i;",
            "            r = i + z[i];",
            "        }",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "Snippet generated from z_function.cpp"
    },
    "suffix_array": {
        "prefix": "suffix_array",
        "body": [
            "const char C = 'a' - 1; // before first letter // change",
            "const char maxchar = 'z'; // change",
            "",
            "vector<int> suffarray(string s)",
            "{ // without $ at the end",
            "    vector<int> p, c, pn, cn, cnt;",
            "    int n = (int)s.size();",
            "    c.assign(n, 0);",
            "    for (int i = 0; i < n; i++) { c[i] = s[i] - C; }",
            "    for (int j = 0; j <= (maxchar - C); j++) {",
            "        for (int i = 0; i < n; i++) {",
            "            if (c[i] == j) { p.push_back(i); }",
            "        }",
            "    }",
            "    int maxc = c[p.back()];",
            "    pn.resize(n);",
            "    for (int k = 0; (1 << k) <= 2 * n; k++) {",
            "        for (int i = 0; i < n; i++) { pn[i] = ((p[i] - (1 << k)) % n + n) % n; }",
            "        cnt.assign(maxc + 3, 0);",
            "        for (int i = 0; i < n; i++) { cnt[c[i] + 1]++; }",
            "        for (int i = 1; i <= maxc + 2; i++) { cnt[i] += cnt[i - 1]; }",
            "        for (int i = 0; i < n; i++) { p[cnt[c[pn[i]]]++] = pn[i]; }",
            "        cn.assign(n, 0);",
            "        cn[p[0]] = 1;",
            "        for (int i = 1; i < n; i++) {",
            "            if (c[p[i]] == c[p[i - 1]]",
            "                && c[(p[i] + (1 << k)) % n] == c[(p[i - 1] + (1 << k)) % n]) {",
            "                cn[p[i]] = cn[p[i - 1]];",
            "            } else {",
            "                cn[p[i]] = cn[p[i - 1]] + 1;",
            "            }",
            "        }",
            "        maxc = cn[p.back()];",
            "        c = cn;",
            "    }",
            "    return p;",
            "}",
            "",
            "vector<int> findlcp(string s, vector<int> p)",
            "{",
            "    vector<int> lcp, mem;",
            "    int n = (int)s.size();",
            "    mem.resize(n);",
            "    for (int i = 0; i < n; i++) { mem[p[i]] = i; }",
            "    lcp.assign(n, 0);",
            "    for (int i = 0; i < n; i++) {",
            "        if (i > 0) { lcp[mem[i]] = max(lcp[mem[i - 1]] - 1, 0); }",
            "        if (mem[i] == n - 1) { continue; }",
            "        while (max(i, p[mem[i] + 1]) + lcp[mem[i]] < n",
            "            && s[i + lcp[mem[i]]] == s[p[mem[i] + 1] + lcp[mem[i]]]) {",
            "            lcp[mem[i]]++;",
            "        }",
            "    }",
            "    return lcp;",
            "}"
        ],
        "description": "Snippet generated from suffix_array.cpp"
    },
    "CHT": {
        "prefix": "CHT",
        "body": [
            "typedef long long integer;",
            "",
            "struct Line {",
            "    integer k, b;",
            "    Line()",
            "        : k(0)",
            "        , b(0)",
            "    {",
            "    }",
            "    Line(integer k, integer b)",
            "        : k(k)",
            "        , b(b)",
            "    {",
            "    }",
            "",
            "    ld operator()(ld x) { return x * (ld)k + (ld)b; }",
            "};",
            "",
            "const integer INF = 2e18; // change",
            "",
            "struct CHT {",
            "    vector<Line> lines;",
            "    bool mini; // cht on minimum",
            "",
            "    ld f(Line l1, Line l2) { return (ld)(l1.b - l2.b) / (ld)(l2.k - l1.k); }",
            "",
            "    void addLine(integer k, integer b)",
            "    {",
            "        if (!mini) {",
            "            k = -k;",
            "            b = -b;",
            "        }",
            "        Line l(k, b);",
            "        while (lines.size() > 1) {",
            "            if (lines.back().k == k) {",
            "                if (lines.back().b > b) {",
            "                    lines.pop_back();",
            "                } else {",
            "                    break;",
            "                }",
            "                continue;",
            "            }",
            "            ld x1 = f(lines.back(), l);",
            "            ld x2 = f(lines.back(), lines[lines.size() - 2]);",
            "            if (x1 > x2) { break; }",
            "            lines.pop_back();",
            "        }",
            "        if (!lines.size() || lines.back().k != k) { lines.push_back(l); }",
            "    }",
            "",
            "    CHT(vector<pair<integer, integer>> v, bool ok = 1)",
            "    { // change",
            "        mini = ok;",
            "        lines.clear();",
            "        for (int i = 0; i < v.size(); i++) { addLine(v[i].first, v[i].second); }",
            "    }",
            "",
            "    integer getmin(integer x)",
            "    { // find of integer!",
            "        if (!lines.size()) { return (mini ? INF : -INF); }",
            "        int l = 0, r = lines.size();",
            "        while (r - l > 1) {",
            "            int mid = (r + l) / 2;",
            "            if (f(lines[mid], lines[mid - 1]) <= (ld)x) {",
            "                l = mid;",
            "            } else {",
            "                r = mid;",
            "            }",
            "        }",
            "        integer ans = lines[l].k * x + lines[l].b;",
            "        return (mini ? ans : -ans);",
            "    }",
            "};"
        ],
        "description": "Snippet generated from CHT.cpp"
    }
}
